<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Histogram Cluster Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background: #111;
            color: #eee;
        }

        svg {
            background: #222;
            border-radius: 10px;
        }

        .bar rect {
            stroke-width: 1;
        }

        .thread {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <h2 style="text-align:center;">D3 Histogram Visualizations</h2>
    <svg width="800" height="400"></svg>
    <script>

        //setup
        const svg = d3.select("svg");
        const width = +svg.attr("width");
        const height = +svg.attr("height");
        const margin = { top: 40, right: 30, bottom: 40, left: 50 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

        // Generate two random datasets
        const dataA = d3.range(200).map(() => d3.randomNormal(30, 10)());
        const dataB = d3.range(200).map(() => d3.randomNormal(50, 10)());
        const bins = d3.bin().domain([0, 80]).thresholds(10);
        const binsA = bins(dataA);
        const binsB = bins(dataB);

        const x = d3.scaleBand()
            .domain(binsA.map((d, i) => i))
            .range([0, innerWidth])
            .paddingInner(0.2);

        const y = d3.scaleLinear()
            .domain([0, d3.max([...binsA, ...binsB], d => Math.max(d.length))])
            .range([innerHeight, 0]);

        const xAxis = g.append("g")
            .attr("transform", `translate(0,${innerHeight})`)
            .call(d3.axisBottom(x).tickFormat(i => {
                const d = binsA[i];
                return `${Math.round(d.x0)}â€“${Math.round(d.x1)}`;
            }));
        g.append("g").call(d3.axisLeft(y));

        /*cluster histohra*/

        function drawClusteredHistogram() {
            const group = g.selectAll(".barGroup").data(binsA).join("g")
                .attr("class", "barGroup")
                .attr("transform", (d, i) => `translate(${x(i)},0)`);

            const subX = d3.scaleBand().domain(["A", "B"]).range([0, x.bandwidth()]).padding(0.05);

            group.selectAll("rect")
                .data((d, i) => [
                    { key: "A", value: binsA[i].length, color: "#69b3a2" },
                    { key: "B", value: binsB[i].length, color: "#ff8c00" }
                ])
                .join("rect")
                .attr("x", d => subX(d.key))
                .attr("y", innerHeight)
                .attr("width", subX.bandwidth())
                .attr("height", 0)
                .attr("fill", d => d.color)
                .transition()
                .duration(800)
                .attr("y", d => y(d.value))
                .attr("height", d => innerHeight - y(d.value));
        }



        function animatePointClustering() {
            const binCenters = binsA.map((b, i) => x(i) + x.bandwidth() / 2);

            const points = g.selectAll(".point")
                .data(dataA)
                .join("circle")
                .attr("class", "point")
                .attr("r", 3)
                .attr("cx", d => d3.scaleLinear().domain([0, 80]).range([0, innerWidth])(d))
                .attr("cy", 0)
                .attr("fill", "#69b3a2")
                .attr("opacity", 0.8);

            points.transition()
                .delay((d, i) => i * 10)
                .duration(1000)
                .attr("cy", d => {
                    const b = binsA.findIndex(bin => d >= bin.x0 && d < bin.x1);
                    return y(binsA[b].length) + Math.random() * 10;
                })
                .attr("cx", d => {
                    const b = binsA.findIndex(bin => d >= bin.x0 && d < bin.x1);
                    return binCenters[b] + (Math.random() - 0.5) * x.bandwidth() / 4;
                })
                .on("end", function (d) {
                    d3.select(this).transition().duration(500).attr("r", 0);
                });

            drawClusteredHistogram();
        }



        function animateGPUStyle() {
            const threadCount = 32;
            const threads = d3.range(threadCount).map(i => ({
                id: i,
                x: Math.random() * innerWidth,
                y: Math.random() * 100,
                bin: Math.floor(Math.random() * binsA.length)
            }));

            const color = d3.scaleSequential(d3.interpolateTurbo).domain([0, threadCount]);

            g.selectAll(".thread")
                .data(threads)
                .join("circle")
                .attr("class", "thread")
                .attr("r", 6)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("fill", d => color(d.id))
                .transition()
                .delay((d, i) => i * 80)
                .duration(1000)
                .attr("cx", d => x(d.bin) + x.bandwidth() / 2)
                .attr("cy", d => y(binsA[d.bin].length) - 10)
                .transition()
                .duration(400)
                .attr("r", 2)
                .on("end", function (d) {
                    binsA[d.bin].length += 1;
                    drawClusteredHistogram();
                });
        }

        // Uncomment next line to see Stage 3
        // animateGPUStyle();

    </script>
</body>

</html>